#include <faunus/faunus.h>

using namespace Faunus;
using namespace Faunus::Potential;

typedef Space<Geometry::Cuboid> Tspace;
typedef CombinedPairPotential<DebyeHuckelShift,CutShift<LennardJones> > Tpairpot;

int main() {


  cout << textio::splash();      // show faunus banner and credits
  InputMap mcp("cosan.input");//read input file
  FormatXTC xtc(1000);                 // XTC gromacs trajectory format

  // Energy functions and space
  auto pot = Energy::NonbondedCutg2g<Tspace,Tpairpot>(mcp)
    + Energy::ExternalPressure<Tspace>(mcp);
  Tspace spc(mcp);

  bool plane = mcp.get("plane", false);

  // Load and add polymer to Space
  auto N    = mcp.get<int>("mol_N",1);
  auto file = mcp.get<string>("mol_file");
  vector<Group> water(N);
  Tspace::ParticleVector v;                   // temporary, empty particle vector
  FormatAAM::load(file,v);                    // load AAM structure into v

  cout << "# Mol volume = " << Geometry::calcVolume(v) << endl;

  for (auto &i : water) {
    Geometry::FindSpace f;
    f.allowMatterOverlap=true;
    if (plane)
      f.dir=Point(1,1,0);
    f.find(spc.geo,spc.p,v);// find empty spot in particle vector
    i = spc.insert(v);                          // Insert into Space
    i.name="cosan";
    spc.enroll(i);
  }

  // Markov moves and analysis
  Move::TranslateRotate<Tspace> gmv(mcp,pot,spc);
  Move::TranslateRotate<Tspace> gmv_short(mcp,pot,spc, "transrot_s");
  if (plane) {
    gmv.directions["cosan"]=Point(1,1,0);
    gmv_short.directions["cosan"]=Point(1,1,0);
  }
  Move::Isobaric<Tspace> iso(mcp,pot,spc);
  Analysis::RadialDistribution<> rdf(0.05);
  Scatter::DebyeFormula<Scatter::FormFactorUnity<>> debye(mcp);
  vector<Point> cm_vec; // vector of mass centers

  spc.load("state"); // load old config. from disk (if any)

  EnergyDrift sys;   // class for tracking system energy drifts
  sys.init( Energy::systemEnergy(spc,pot,spc.p)  ); // store total energy

  cout << atom.info() + spc.info() + pot.info() + textio::header("MC Simulation Begins!");

  MCLoop loop(mcp);            // class for handling mc loops
  while ( loop.macroCnt() ) {  // Markov chain 
    while ( loop.microCnt() ) {
      int i=slp_global.rand() % 2;
      int j,k=water.size();
      Group g;
      switch (i) {
        case 0:
          while (k-->0) {
            j=slp_global.rand() % (water.size());
            if (slp_global()>0.5) {
              gmv.setGroup(water[j]);
              sys+=gmv.move();          // translate/rotate polymers
            }
            else {
              gmv_short.setGroup(water[j]);
              sys+=gmv_short.move();          // translate/rotate polymers
            }
          }
          break;
        case 1:
          sys+=iso.move();
          break;
      }

      // sample oxygen-oxygen rdf
      if (slp_global()>0.95) {
        //auto id = atom["OW"].id;
        //rdf.sample(spc,id,id);
        cm_vec.clear();
        for (auto &i : water)
          cm_vec.push_back(i.cm);
        debye.sample(cm_vec,spc.geo.getVolume());
      }
      if (slp_global()<0.01 ) {
        xtc.setbox( spc.geo.len );
        xtc.save("traj.xtc", spc);
      }

    } // end of micro loop

    sys.checkDrift(Energy::systemEnergy(spc,pot,spc.p)); // energy drift?

    cout << loop.timing();
  } // end of macro loop

  // save to disk
  FormatPQR::save("confout.pqr", spc.p);
  spc.save("state");
  rdf.save("rdf.dat");
  spc.save("state");
  FormatPQR::save("confout.pqr", spc.p, spc.geo.len);
  FormatXYZ::save("confout.xyz", spc.p);
  debye.save("debye.dat");

  {
    int natom=0,nres=1;
    Point len = spc.geo.len/10.;
    char buf[79];
    std::ofstream o;
    o.open("confout.gro");
    if (o) {
      o << "Generated by Faunus -- http://faunus.sourceforge.net"
        << std::endl << spc.p.size() << std::endl;
      for (auto i : spc.p) {
        auto t=i/10. + len/2.;
        string name=atom[i.id].name;
        sprintf(buf, "%5d%5s%5s%5d%8.3f%8.3f%8.3f\n",
            nres,name.c_str(),name.c_str(),natom++,
            i.x(), i.y(), i.z() );
        o << buf;
      }
      o << len.transpose() << endl;
    }
  }

  // perform unit 
  UnitTest test(mcp);
  iso.test(test);
  gmv.test(test);
  sys.test(test);

  // print information
  cout << loop.info() + sys.info() + "LONG\n" + gmv.info() + "SHORT!\n" + gmv_short.info() 
    + iso.info() + test.info();
}

